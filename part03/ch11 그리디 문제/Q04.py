# 만들 수 없는 금액
# 답안 참조함

n = int(input())
coins = sorted(list(map(int, input().split())))
num = 1
for c in coins:
    print(num, c)
    if num < c:
        break
    num += c

print(num)


'''
input
5
3 2 1 1 9
output
8

input
5
1 2 3 4 5
output
16

input
6
1 2 4 8 16 32
output
64
'''


'''
이해가 안되서 풀이를 여러번 봤음

일단 N은 1000개 까지이며, 각 동전은 1,000,000 까지이다
여기에서 그리디 인것을 일단 눈치채야 할듯

먼저 num은 정수의 최소값인 1부터 시작해야함 = 확인해야 될 숫자

for 문에서 정렬된 coins를 하나씩 탐색하는데
시작되는 coin이 1을 넘는다면 1을 만들 수 없는 거는 ok
만약 만들 수 있다면 coins에는 1이 포함되어있다는거니깐 다음숫자 2를 확인

2번째 for문에서 만약 coins[1]이 3이라면? [1, 3] -> 2를 만들 수 없음
만약 coins[1]이 1이나 2 라면? [1, 1] or [1, 2] -> 1, 2 or 1, 2, 3
그렇다면 다음 3번째 반복문에서는 3 or 4를 확인 해야함

3번째 for문에서 만약 coins[2]이 3 or 4 이상이라면?
num=3, [1, 1, 3] -> [1, 2, 3, 4, 5] 까지 확인되는거니깐 다음 num은 6이 되어야함
num=3, [1, 1, 4] -> [1, 2, 4, 5, 6] 인데 기존의 [1, 1]이 [1, 2]의 값을 가진다는걸 확인하고 num=3이였음, 현재 coin이 3 초과로 3을 만들 수 없음

생각보다 굉장히 복잡합
오름차순으로 정렬되어 있는 coins에서
num = 1부터 시작, coins를 1개씩 num에 더해주면서 만약 현재 coin이 전에 더해둔 num보다 크다면? -> 사이에 공백이 발생


3번째 예시를 직접 생각해보는게 가장 이해가 빠를듯
1일 때, 1까지 모든 정수를 만들 수 있음 
2 (num+1)일 때, 현재 2, 1+2 = 3까지 모든 정수를 만들 수 있음, 다음 3+1(다음 자연수) =4부터 확인해보면 ->
4 (num+2)일 때, 현재 4, 1+2+4 = 7까지 모든 정수를 만들 수 있음, 다음 7+1부터 확인해보면 ->
8 (num+4)일 때, 현재 8, 1+2+4+8 = 15까지 모든 정수를 만들 수 있음, 다음 15+1부터 확인해보면 ->
'''