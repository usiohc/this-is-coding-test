# 아이디어를 코드로 바꾸는 구현
## 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정

- 완전탐색(브루트 포스) : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법

- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

#### 둘 다 구현이 핵심이 되는 경우가 많음

<br>

### 예제 4-1 상하좌우

- N * N 으로 이루어진 정사각형 공간 (N, N)   

- 가장 왼쪽 위 좌표는 (1, 1)로 시작하고 가장 오른쪽 아래가 (N, N)   

- A는 L, R, U, D 명령어로 왼 오 위 아래 로 움직일 수 있으나 공간을 벗어나는 움직임은 무시   

말그대로 간단한 구현문제, 정사각형을 벗어나는 조건만 작성하면됨

<br>

### 예제 4-2 시각

- 00시 00분 00초 부터 N시 59분 59초까지 3이 하나라도 포함되는 경우의 수

- 브루트 포스 알고리즘으로 접근

- n이 24일때 모든 경우의 수가 24 * 60 * 60이 최대, 즉 3중 반복문으로 풀어도됨

처음에 h, m, s 변수를 int형으로 접근하다보니 단순히 3이라는 숫자가 존재하는지 확인해야 하는 것을 int 타입의 3이라는 숫자를 찾다보니깐 30, 13 등의 수를 놓치고 있었다.

그래서 str형으로 형변환하여 '3'을 찾아내도록 if _ in _ 을 사용하였다.

<br>

### 예제 4-3 왕실의 나이트

- 체스판 8*8 의 크기
- 나이트는 항상 L자 형태로만 이동, 체스판 밖으로는 나갈 수 없음
- 행 위치는 1~8로, 열 위치는 a~h로 표현


#### 두 가지 방법으로만 움직일 수 있음
- 수평으로 두 칸 이동 후 수직으로 한 칸 이동
- 수직으로 두 칸 이동 후 수평으로 한 칸 이동

나이트가 이동할 수 있는 경우의 수를 출력.

나이트는 기본적으로 8개의 경우를 가지는데 체스판 밖으로 이동을 하지 못하는 경우를 구현해야 한다.

2차원 리스트로 이동하는 위치를 미리 선언하여 for _ in _ 문으로 8가지 경우의 수를 확인하고, 만약 체스판 내부에 위치하고 있으면 카운트를 증가하도록 했다.

