# 아이디어를 코드로 바꾸는 구현
## 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정

- 완전탐색(브루트 포스) : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법

- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

#### 둘 다 구현이 핵심이 되는 경우가 많음

<br>

### 예제 4-1 상하좌우

- N * N 으로 이루어진 정사각형 공간 (N, N)   

- 가장 왼쪽 위 좌표는 (1, 1)로 시작하고 가장 오른쪽 아래가 (N, N)   

- A는 L, R, U, D 명령어로 왼 오 위 아래 로 움직일 수 있으나 공간을 벗어나는 움직임은 무시   

말그대로 간단한 구현문제, 정사각형을 벗어나는 조건만 작성하면됨

<br>

### 예제 4-2 시각

- 00시 00분 00초 부터 N시 59분 59초까지 3이 하나라도 포함되는 경우의 수

- 브루트 포스 알고리즘으로 접근

- n이 24일때 모든 경우의 수가 24 * 60 * 60이 최대, 즉 3중 반복문으로 풀어도됨

처음에 h, m, s 변수를 int형으로 접근하다보니 단순히 3이라는 숫자가 존재하는지 확인해야 하는 것을 int 타입의 3이라는 숫자를 찾다보니깐 30, 13 등의 수를 놓치고 있었다.

그래서 str형으로 형변환하여 '3'을 찾아내도록 if _ in _ 을 사용하였다.

<br>

### 예제 4-3 왕실의 나이트

- 체스판 8*8 의 크기
- 나이트는 항상 L자 형태로만 이동, 체스판 밖으로는 나갈 수 없음
- 행 위치는 1~8로, 열 위치는 a~h로 표현


#### 두 가지 방법으로만 움직일 수 있음
- 수평으로 두 칸 이동 후 수직으로 한 칸 이동
- 수직으로 두 칸 이동 후 수평으로 한 칸 이동

나이트가 이동할 수 있는 경우의 수를 출력.

나이트는 기본적으로 8개의 경우를 가지는데 체스판 밖으로 이동을 하지 못하는 경우를 구현해야 한다.

2차원 리스트로 이동하는 위치를 미리 선언하여 for _ in _ 문으로 8가지 경우의 수를 확인하고, 만약 체스판 내부에 위치하고 있으면 카운트를 증가하도록 했다.

<br>

### 예제 4-4 게임 개발

#### 게임 캐릭터가 맵 안에서 움직이는 시스템

- N * M 크기의 직사각형이고, 칸은 육지 또는 바다로 이루어짐
- 맵에서 칸의 위치는 (A, B)로 표현하고 A는 행, B는 열로 표현한다.
- 캐릭터는 바다로 되어 있는 공간은 갈 수 없다.

#### 캐릭터의 움직임은 이러하다

1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 갈 곳을 정한다.   
2. 캐릭터의 바로 왼쪽 방향에 가보지 않은 칸이 존재하면, 왼쪽방향으로 회전한 다음 왼쪽으로 한칸 전진한다. 만약 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.
3. 만약 네방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽방향이 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.

캐릭터가 방문한 칸의 수를 출력

