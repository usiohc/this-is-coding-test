# 다이나믹 프로그래밍 (DP)
### 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘

메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법.    
동적 계획법이라고 표현하기도 하며, 2가지 방식을 다룰 것이다.


<br>

## 중복되는 연산을 제거

대표적인 예로는 피보나치 수열이 있다.    
피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.

1 1 2 3 5 8 13 21 34 55 89

수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현하는데, 점화식이란 인접한 항들 사이의 관계식을 의미한다.    
예를 들어 수열 a<sub>n</sub>이 있을 때 수열에서의 각 항을 a<sub>n</sub>이라고 부른다고 가정하자.   


우리는 **점화식** 을 이용해 현재의 항을 이전의 항에 대한 식으로 표현할 수 있다.    


$$ 
a_{n+2} = f(a_{n+1}, a_n) = a_{n+1} + a_n
$$

이러한 점화식은 인접 3항간 점화식 이라고 부르는데 인접한 총 3개의 항에 대해서 식이 정의되기 때문이다.   

등차수열의 점화식은 다음과 같이 표현할 수 있다.    

$$ 
a_{n+1} = f(a) = a_n + 1
$$


프로그래밍 에서는 이러한 수열을 **배열**이나 **리스트**로 표현할 수 있다.    
수열 자체가 여러 개의 규칙에 따라서 배열된 형태를 의미하는 것이기 때문이다.

그렇다면  f(4)를 구하려면 다음과 같이 함수 f를 반복해서 호출할 것 이다. 그런데 f(2)와 f(1)은 항상 1이기 때문에 f(2)이나 f(2)를 만났을 때는 호출을 정지한다.

#### 8-1 피보나치 함수 소스코드

    def fibo(x):
        if x==1 or x==2:
            return 1
        return fibo(x-1) + fibo(x-2)
    
    print(fibo(4))

그런데 피보나치 수열의 소스코드를 이렇게 작성하면 심각한 문제가 생길 수 있다. 바로f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다.

f(6) 일때의 호출 과정을 확인해보자.

```bash
└── f(6)
    ├── f(5)
    │   ├── f(4)
    │   │   ├── f(3)
    │   │   │   ├── f(2)
    │   │   │   └── f(1)
    │   │   └── f(2)
    │   └── f(3)
    │       ├── f(2)
    │       └── f(1)
    └── f(4)
        ├── f(3)
        │   ├── f(2)
        │   └── f(1)
        └── f(2)
``` 

과정을 보면 동일한 함수가 반복적으로 호출 되는 것을 알 수 있는데, 이미 한 번 계산 했지만, 계속 호출할 때마다 계산을 하고 있는 것이다.   
그림에서 f(3)은 총 3번 호출 되었는데, n이 커질수록 반복해서 호출하는 수가 많아진다. 예를 들어 f(100)을 계산 하려면 2<sup>10</sup>을 약 1000이라고 가정 했을 때, 연산 횟수는 약 10<sup>28</sup>번이다. 아마 현대의 2진수 처리 방식을 가진 컴퓨터 구조에 기반한 시스템에서 연산을 수행하면 우리의 수명이 다할 때까지 연산을 진행해도 답을 도출할 수 없을 것이다.


