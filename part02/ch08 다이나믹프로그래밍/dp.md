# 다이나믹 프로그래밍 (DP)
### 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘

메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법.    
동적 계획법이라고 표현하기도 하며, 2가지 방식을 다룰 것이다.


<br>

## 중복되는 연산을 제거

대표적인 예로는 피보나치 수열이 있다.    
피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.

1 1 2 3 5 8 13 21 34 55 89

수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현하는데, 점화식이란 인접한 항들 사이의 관계식을 의미한다.    
예를 들어 수열 a<sub>n</sub>이 있을 때 수열에서의 각 항을 a<sub>n</sub>이라고 부른다고 가정하자.   


우리는 **점화식** 을 이용해 현재의 항을 이전의 항에 대한 식으로 표현할 수 있다.    


$$ 
a_{n+2} = f(a_{n+1}, a_n) = a_{n+1} + a_n
$$

이러한 점화식은 인접 3항간 점화식 이라고 부르는데 인접한 총 3개의 항에 대해서 식이 정의되기 때문이다.   

등차수열의 점화식은 다음과 같이 표현할 수 있다.    

$$ 
a_{n+1} = f(a) = a_n + 1
$$


프로그래밍 에서는 이러한 수열을 **배열**이나 **리스트**로 표현할 수 있다.    
수열 자체가 여러 개의 규칙에 따라서 배열된 형태를 의미하는 것이기 때문이다.

그렇다면  f(4)를 구하려면 다음과 같이 함수 f를 반복해서 호출할 것 이다.     
그런데 f(2)와 f(1)은 항상 1이기 때문에 f(2)이나 f(2)를 만났을 때는 호출을 정지한다.

#### 8-1 피보나치 함수 소스코드

    def fibo(x):
        if x==1 or x==2:
            return 1
        return fibo(x-1) + fibo(x-2)
    
    print(fibo(4))

그런데 피보나치 수열의 소스코드를 이렇게 작성하면 심각한 문제가 생길 수 있다.     
바로f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다.

f(6) 일때의 호출 과정을 확인해보자.

```bash
└── f(6)
    ├── f(5)
    │   ├── f(4)
    │   │   ├── f(3)
    │   │   │   ├── f(2)
    │   │   │   └── f(1)
    │   │   └── f(2)
    │   └── f(3)
    │       ├── f(2)
    │       └── f(1)
    └── f(4)
        ├── f(3)
        │   ├── f(2)
        │   └── f(1)
        └── f(2)
``` 
<br>

과정을 보면 동일한 함수가 반복적으로 호출 되는 것을 알 수 있는데, 이미 한 번 계산 했지만, 계속 호출할 때마다 계산을 하고 있는 것이다.   

그림에서 f(3)은 총 3번 호출 되었는데, n이 커질수록 반복해서 호출하는 수가 많아진다. 예를 들어 f(100)을 계산 하려면 2<sup>10</sup>을 약 1000이라고 가정 했을 때, 연산 횟수는 약 10<sup>28</sup>번이다.     

아마 현대의 2진수 처리 방식을 가진 컴퓨터 구조에 기반한 시스템에서 연산을 수행하면 우리의 수명이 다할 때까지 연산을 진행해도 답을 도출할 수 없을 것이다.

#
 
이처럼 피보나치 수열의 점화실을 재귀 함수를 사용해 만들 수는 있지만, 단순히 매번 계산하도록 하면 문제를 효율적으로 해결할 수 없다.    
이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있는데, 다만 항상 다이나믹 프로그래밍을 사용할 수는 없으며 다음 조건을 만족할 때 사용할 수 있다.    

### 1. 큰 문제를 작은 문제로 나눌 수 있다.
### 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열은 이러한 조건을 만족하는 대표 문제이다.   

이 문제를 메모이제이션 기법을 사용해서 해결해보자.
메모이 제이션은 다이나믹 프로그래밍을 구현하는 방법중 한 종류로, 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의마한다.   

메모이제이션은 값을 저장하는 방법이라고 **캐싱**이라고도 한다.

#### 8-2 피보나치 수열 소스코드(재귀)

    dp = [0] * 100

    def fibo(x):
        if x==1 or x==2:
            return 1
        
        if dp[x] != 0:
            return dp[x]

        dp[x] = fibo(x-1) + fibo(x-2)
        return dp[x]
    
    print(fibo(99))

소스코드를 실행했을 때 99번째 피보나치 수를 구하도록 했음에도 불구하고 금방 정답을 도출하는 것을 알 수 있다.

#

함수가 종료될 때 어떤 함수를 호출했는지, 현재의 피보나치 수를 출력하도록 코드를 만들면 실제로 그림처럼 호출된다는 것을 알 수 있다. 이로써 시간 복잡도가 O(N)이라는 것을 쉽게 이해할 수 있다.

#### 8-3 호출되는 함수 확인

    dp = [0] * 100

    def fibo(x):
        print('f(' + str(x) + ')', end = ' ')
        if x==1 or x==2:
            return 1
        
        if dp[x] != 0:
            return dp[x]

        dp[x] = fibo(x-1) + fibo(x-2)
        return dp[x]
    
    print(fibo(6))

    출력 결과 : f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3)f(4)

<br>

이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 **탑다운<sup>Top-Down</sup>방식**이라고 한다.

반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 **바텀업<sup>Bottom-Up</sup>방식**이라고 말한다.

#

피보나치 수열 문제를 아래에서 위로 올라가는 보텀업 방식으로 풀면 다음과 같다.
동일한 원리를 적용하되 단순히 반복문을 이용하여 문제를 해결한 것으로 이해하면 된다.

#### 8-4 피보나치 수열 소스코드(반복)

    d = [0] * 100

    d[1] = 1
    d[2] = 1
    n = 99

    for i in range(3, n+1):
        d[i] = d[i-1] + d[i-2]
    
    print(d[n])


#

### 탑다운(메모이제이션) 방식은 **하향식** 이라고도 하며
### 바텀업 방식은 **상향식** 이라고도 한다.

다이나믹 프로그래밍의 전형적인 형태는 상향식 방식이다. 상향식 방식에서 사용되는 결과 저장용 리스트는 **DP 테이블** 이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.

<br>

#

### 예제 8-5 1로 만들기
#### 연산 4개를 적절히 사용해서 최소 횟수로 1을 만들기

처음 문제를 봤을 때는 그냥 min(4개 공식)을 해서 연산을 할 때마다 최솟값을 가지고 cnt++를 해주려고 했었다.   

예제 입력값인 26을 기준으로 봤을 때, 제일 낮은 값은 3으로 나눠서 12을 만드는 것이였다.

    26//3 = 12, 12//3 = 4, 4//2 = 2, 2-1 = 1

만약 3으로 나눠서 최솟값을 가지는 방식으로 진행을 했다면 출력은 4로 나올 것 이다.

그래서 dp를 사용해 보기 위해 캐싱할 수 있는 값이 뭔지 생각을 해봤는데

    dp = [0] * (x+1)

DP 테이블을 초기화 해주고 
    
    for i in range(2, x+1)

반복문을 사용해 i에서 1로 가는 최솟값을 dp에 저장하기로 했다.

    dp[2] = 1
    dp[3] = 1
    dp[4] = 2
    dp[5] = 1
    dp[6] = 2

dp의 앞쪽 index의 값만 나열해 봤을 때, 드는 생각이 2, 3, 5의 값은 무조건 1이 나오게 된다는 것이다.

#### i = 6 일때, 6은 3이나 2의 배수이고,    
### dp[6] == dp[2]+1 || dp[3]+1 이라는 것이다.

여기서 힌트를 얻었고, 문제를 해결할 수 있었다.


#

### 예제 8-6 개미 전사
#### 인접하지 않은 리스트들의 최대값 구하기

8-5와 비슷한 문제인것 같아서 처음 시도에 바로 해결할 수 있었다.

인접하지 않는 조건은 dp[0]으로 시작하거나 dp[1]로 시작하는 조건만 가지고 dp[2]부터 반복문으로 해결할 수 있다고 생각했고,   
max(dp[i-2] + array[i], dp[i-1])의 점화식을 바로 생각해냈다.

#

### 예제 8-7 바닥 공사
#### 경우의 수 구하는 점화식을 찾기

먼저 이번 문제를 풀면서 느낀점은 dp를 구현하는 것 자체는 어렵지 않다.    
다만 dp를 구하기 위한 점화식을 생각해 내는 것이 어려운 것 이다.

처음에 dp[1], dp[2]의 값을 구하고 예제로 있는 dp[3]이 5인 것은 이해하였는데 dp[4]를 손으로 직접 그래가면서 11번의 경우의 수가 있는 것은 알겠으나 점화식을 생각해 내는데 시간이 많이 필요했었다.

dp[4]일때, dp[3]에서 1 * 2의 크기를 가진 덮개와 dp[2]에서 2 * 2의 크기를 가진 덮개의 경우의 수는 dp[2]인 3이지만 1*2의 덮개는 이미 계산되어 있기 때문에 2라고 할 수 있다.

그렇다면 dp[4]는 dp[3] + dp[2]+dp[2] 라고 할 수 있다.





