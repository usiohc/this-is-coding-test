# 다이나믹 프로그래밍 (DP)
### 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘

메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법.    
동적 계획법이라고 표현하기도 하며, 2가지 방식을 다룰 것이다.


<br>

## 중복되는 연산을 제거

대표적인 예로는 피보나치 수열이 있다.    
피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.

1 1 2 3 5 8 13 21 34 55 89

수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현하는데, 점화식이란 인접한 항들 사이의 관계식을 의미한다.    
예를 들어 수열 a<sub>n</sub>이 있을 때 수열에서의 각 항을 a<sub>n</sub>이라고 부른다고 가정하자.   


우리는 **점화식** 을 이용해 현재의 항을 이전의 항에 대한 식으로 표현할 수 있다.    


$$ 
a_{n+2} = f(a_{n+1}, a_n) = a_{n+1} + a_n
$$

이러한 점화식은 인접 3항간 점화식 이라고 부르는데 인접한 총 3개의 항에 대해서 식이 정의되기 때문이다.   

등차수열의 점화식은 다음과 같이 표현할 수 있다.    

$$ 
a_{n+1} = f(a) = a_n + 1
$$


프로그래밍 에서는 이러한 수열을 **배열**이나 **리스트**로 표현할 수 있다.    
수열 자체가 여러 개의 규칙에 따라서 배열된 형태를 의미하는 것이기 때문이다.

그렇다면  f(4)를 구하려면 다음과 같이 함수 f를 반복해서 호출할 것 이다.     
그런데 f(2)와 f(1)은 항상 1이기 때문에 f(2)이나 f(2)를 만났을 때는 호출을 정지한다.

#### 8-1 피보나치 함수 소스코드

    def fibo(x):
        if x==1 or x==2:
            return 1
        return fibo(x-1) + fibo(x-2)
    
    print(fibo(4))

그런데 피보나치 수열의 소스코드를 이렇게 작성하면 심각한 문제가 생길 수 있다.     
바로f(n) 함수에서 n이 커지면 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다.

f(6) 일때의 호출 과정을 확인해보자.

```bash
└── f(6)
    ├── f(5)
    │   ├── f(4)
    │   │   ├── f(3)
    │   │   │   ├── f(2)
    │   │   │   └── f(1)
    │   │   └── f(2)
    │   └── f(3)
    │       ├── f(2)
    │       └── f(1)
    └── f(4)
        ├── f(3)
        │   ├── f(2)
        │   └── f(1)
        └── f(2)
``` 
<br>

과정을 보면 동일한 함수가 반복적으로 호출 되는 것을 알 수 있는데, 이미 한 번 계산 했지만, 계속 호출할 때마다 계산을 하고 있는 것이다.   

그림에서 f(3)은 총 3번 호출 되었는데, n이 커질수록 반복해서 호출하는 수가 많아진다. 예를 들어 f(100)을 계산 하려면 2<sup>10</sup>을 약 1000이라고 가정 했을 때, 연산 횟수는 약 10<sup>28</sup>번이다.     

아마 현대의 2진수 처리 방식을 가진 컴퓨터 구조에 기반한 시스템에서 연산을 수행하면 우리의 수명이 다할 때까지 연산을 진행해도 답을 도출할 수 없을 것이다.

#
 
이처럼 피보나치 수열의 점화실을 재귀 함수를 사용해 만들 수는 있지만, 단순히 매번 계산하도록 하면 문제를 효율적으로 해결할 수 없다.    
이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있는데, 다만 항상 다이나믹 프로그래밍을 사용할 수는 없으며 다음 조건을 만족할 때 사용할 수 있다.    

### 1. 큰 문제를 작은 문제로 나눌 수 있다.
### 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열은 이러한 조건을 만족하는 대표 문제이다.   

이 문제를 메모이제이션 기법을 사용해서 해결해보자.
메모이 제이션은 다이나믹 프로그래밍을 구현하는 방법중 한 종류로, 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의마한다.   

메모이제이션은 값을 저장하는 방법이라고 **캐싱**이라고도 한다.

#### 8-2 피보나치 수열 소스코드(재귀)

    dp = [0] * 100

    def fibo(x):
        if x==1 or x==2:
            return 1
        
        if dp[x] != 0:
            return dp[x]

        dp[x] = fibo(x-1) + fibo(x-2)
        return dp[x]
    
    print(fibo(99))

소스코드를 실행했을 때 99번째 피보나치 수를 구하도록 했음에도 불구하고 금방 정답을 도출하는 것을 알 수 있다.

#

함수가 종료될 때 어떤 함수를 호출했는지, 현재의 피보나치 수를 출력하도록 코드를 만들면 실제로 그림처럼 호출된다는 것을 알 수 있다. 이로써 시간 복잡도가 O(N)이라는 것을 쉽게 이해할 수 있다.

#### 8-3 호출되는 함수 확인

    dp = [0] * 100

    def fibo(x):
        print('f(' + str(x) + ')', end = ' ')
        if x==1 or x==2:
            return 1
        
        if dp[x] != 0:
            return dp[x]

        dp[x] = fibo(x-1) + fibo(x-2)
        return dp[x]
    
    print(fibo(6))

    출력 결과 : f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3)f(4)

<br>

이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 **탑다운<sup>Top-Down</sup>방식**이라고 한다.

반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 **바텀업<sup>Bottom-Up</sup>방식**이라고 말한다.

#

피보나치 수열 문제를 아래에서 위로 올라가는 보텀업 방식으로 풀면 다음과 같다.
동일한 원리를 적용하되 단순히 반복문을 이용하여 문제를 해결한 것으로 이해하면 된다.

#### 8-4 피보나치 수열 소스코드(반복)

    d = [0] * 100

    d[1] = 1
    d[2] = 1
    n = 99

    for i in range(3, n+1):
        d[i] = d[i-1] + d[i-2]
    
    print(d[n])


#

### 탑다운(메모이제이션) 방식은 **하향식** 이라고도 하며
### 바텀업 방식은 **상향식** 이라고도 한다.

다이나믹 프로그래밍의 전형적인 형태는 상향식 방식이다. 상향식 방식에서 사용되는 결과 저장용 리스트는 **DP 테이블** 이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.



