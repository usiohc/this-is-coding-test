# 그리디 알고리즘   
## 현재 상황에서 지금 당장 좋은 것만 고르는 방법   

<br>

### 예제 3-1 거스름돈   

- 화폐의 종류가 K일때, 시간복잡도는 O(K)   

가지고 있는 동전중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문

#### 예) 800원의 거스름돈을 화폐 단위가 500원, 400원, 100원 인 경우

그리디 알고리즘은 500 + 100 + 100 + 100 으로 거슬러 줘야 한다고 나오는데   
최적의 해는 2개의 동전 400 + 400 으로 거슬러 주는 것

이 문제에서는 큰 단위가 작은 단위의 뱌수 형태 이므로 가장 큰 단위부터 차례대로 확인하는 작업만 수행하면 된다.

#### 대부분의 그리디 알고리즘 문제는 최소한의 아이디어와 이를 증명 할수 있어야 한다.

<br>

### 예제 3-2 큰 수의 법칙   

- M번을 K번 초과하지 않게 더해야함   

이는 가장 큰 수를 K번 더하고 2번째 큰 수를 한번만 더하면 됌

3-2.py 코드에서 작성한 코드를 보면 주석문에는 직접 계산하면서 문제를 해결했으나   

아래쪽의 코드에서는 반복되는 수열을 파악하여 단순 연산으로만 계산하였음

<br>

### 예제 3-3 숫자 카드 게임

- 각 행마다 가장 작은 수를 찾은 뒤에 그수 중에서 가장 큰 수

이는 결국에 행마다 작은 수들중 가장 큰수를 찾으라는 것   

처음에 생각한 알고리즘은 행마다 입력을 받으면 min함수로 전역 리스트에 추가하고 모든 입력이 끝나면 max함수로 전역 리스트에서 가장 큰 값을 출력 하려고 했으나   

코드를 작성하고 정답을 보니 굳이 그럴 필요가 없었음을 이해 하였음,   
그냥 전역 변수를 선언하고 max함수로 행마다 비교해서 계속 진행하면 되는거였음

<br>

### 예제 3-4 1이 될 때까지

- 1번 조건인 -1보다 // 연산을 하는게 더 빠름

처음에는 그냥 n > 1 으로 while문을 돌렸는데 25 3 입력에서 7이 나오는 것을 확인하고 다시 조건을 설정했다.   

else 문에서 -1한번씩 하는 것이 아니라 나눌 수 있는 값으로 만들때 나머지 만큼 빼는 연산을 하면서 마지막 연산과정에서 1이 아니라 0으로 만들어 버리는 것이 문제였다.   

물론 -1씩 하면서 result에 +1씩 하면 되는 것이였지만, n이 k보다 작아졌을때 반복문을 탈출 하는 것으로 하고 result를 출력하기 전에 n이 1인지 확인하면서 -1을 하는 반복문을 하나 더 추가하였다.